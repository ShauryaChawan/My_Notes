[üè† Home](../../../README.md) <br/>
[üçµ Java Home](../Java.md)

<hr/>

<h1 style="text-align: center">20. Java Polymorphism</h1>

<hr/>

## Introduction

Polymorphism is a fundamental concept in object-oriented programming (OOP) that allows objects of different classes to be treated as objects of a common superclass.

There are two main types of polymorphism in Java:

- Compile-Time Polymorphism (Method Overloading)
- Runtime Polymorphism (Method Overriding)

## Compile-Time Polymorphism (Method Overloading)

Method overloading allows a class to have more than one method with the same name, but different parameter lists (type, number, or both).

```java
class Calculator {
  // Method to add two integers
  public int add(int a, int b) {
    return a + b;
  }

  // Overloaded method to add three integers
  public int add(int a, int b, int c) {
    return a + b + c;
  }

  // Overloaded method to add two doubles
  public double add(double a, double b) {
    return a + b;
  }
}

public class Main {
  public static void main(String[] args) {
    Calculator calc = new Calculator();

    // Calls the method with two integers
    System.out.println("Sum of 5 and 10: " + calc.add(5, 10));

    // Calls the method with three integers
    System.out.println("Sum of 5, 10, and 15: " + calc.add(5, 10, 15));

    // Calls the method with two doubles
    System.out.println("Sum of 5.5 and 10.5: " + calc.add(5.5, 10.5));
  }
}

// Output:
// ----------
// Sum of 5 and 10: 15
// Sum of 5, 10, and 15: 30
// Sum of 5.5 and 10.5: 16.0
```

## Runtime Polymorphism (Method Overriding)

Method overriding allows a subclass to provide a specific implementation of a method that is already defined in its superclass. 
This type of polymorphism is resolved at runtime.

**Example:**
```java
// Superclass
class Animal {
  // Method to be overridden
  public void makeSound() {
    System.out.println("Some generic animal sound");
  }
}

// Subclass overriding the superclass method
class Dog extends Animal {
  @Override
  public void makeSound() {
    System.out.println("Bark");
  }
}

// Another subclass overriding the superclass method
class Cat extends Animal {
  @Override
  public void makeSound() {
    System.out.println("Meow");
  }
}

public class Main {
  public static void main(String[] args) {
    Animal myAnimal;

    // Reference of type Animal but object of type Dog
    myAnimal = new Dog();
    myAnimal.makeSound(); // Outputs "Bark"

    // Reference of type Animal but object of type Cat
    myAnimal = new Cat();
    myAnimal.makeSound(); // Outputs "Meow"
  }
}

// Output:
// ----------
// Bark
// Meow
```

## `@Override` Annotation

- The `@Override` annotation in Java is used to indicate that a method is intended to override a method in a superclass. 
- It provides several benefits:
  - **Compile-Time Checking:** The compiler checks if the method actually overrides a method in the superclass. If not, it will generate a compile-time error.
  - **Code Readability:** It makes the code clearer by explicitly showing that a method is meant to override a superclass method.

**Example:** Here‚Äôs how it's used:
```java
class Animal {
  public void makeSound() {
    System.out.println("Some generic animal sound");
  }
}

class Dog extends Animal {
  @Override
  public void makeSound() {
    System.out.println("Bark");
  }
}
```

## Does Java supports 'Operator Overloading & Overriding' like C++?

Java does not support **operator overloading**. This means you cannot define multiple behaviors for standard operators (like `+`, `-`, `*`, etc.) based on the operand types.

Java does not support operator overriding either. **Operator overriding** is a concept where operators behave differently in subclasses, which is not allowed in Java.

<hr/>

[üè† Home](../../../README.md) <br/>
[üçµ Java Home](../Java.md)
