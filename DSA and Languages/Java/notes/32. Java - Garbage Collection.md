[üè† Home](../../../README.md) <br/>
[üçµ Java Home](../Java.md)

<hr/>

<h1 style="text-align: center">31. Java Garbage Collection</h1>

- [Introduction](#introduction)
- [How can an object be unreferenced?](#how-can-an-object-be-unreferenced)
- [How Garbage Collection Works](#how-garbage-collection-works)
- [Types of Garbage Collectors](#types-of-garbage-collectors)
- [Automatic GC Examples and Code Explanation](#automatic-gc-examples-and-code-explanation)
  - [Example 1: Basic Garbage Collection](#example-1-basic-garbage-collection)
  - [Example 2: Generational Garbage Collection](#example-2-generational-garbage-collection)
- [The `finalize()`](#the-finalize)

<hr/>

## Introduction

- Java Garbage Collection (GC) is a crucial aspect of memory management in the Java programming language.
- It automatically handles the reclamation of memory that is no longer in use, freeing up resources and preventing memory leaks.
- It is designed to efficiently manage the heap memory.

## How can an object be unreferenced?

There are many ways, but the most common ways are:
1. By nulling the reference
2. By assigning a reference to another
3. By anonymous object etc.

**Example:** By nulling a reference:

```java
Employee e=new Employee();  
e=null;  
```

**Example:** By assigning a reference to another:

```java
Employee e1=new Employee();  
Employee e2=new Employee();  
e1=e2;

//now the first object referred by e1 is available for garbage collection  
```

**Example:** By anonymous object:

```java
new Employee();  
```

## How Garbage Collection Works

1. **Object Creation and Reachability:**

   - Objects are created on the heap memory. 
   - An object is considered "reachable" if it can be accessed directly or indirectly from the roots (e.g., static fields, local variables, etc.).

2. **Mark-and-Sweep Algorithm:**

   - **Mark Phase:** The GC identifies which objects are still reachable from the root.
   - **Sweep Phase:** The GC reclaims the memory used by objects that are not marked as reachable.

3. **Generational Garbage Collection:**

   - **Young Generation:** This area is where new objects are allocated. It consists of the Eden Space and two Survivor Spaces (S0 and S1).
   - **Old Generation (Tenured Generation):** This area stores long-lived objects that survive several garbage collection cycles.
   - **Permanent Generation (Metaspace in JDK 8+):** Stores metadata about classes and methods.

## Types of Garbage Collectors

1. **Serial Garbage Collector:**

   - Designed for single-threaded environments.
   - Example: Use the -XX:+UseSerialGC option.

2. **Parallel Garbage Collector:**

   - Uses multiple threads for garbage collection, suitable for multi-threaded applications.
   - Example: Use the -XX:+UseParallelGC option.

3. **Concurrent Mark-Sweep (CMS) Garbage Collector:**

- Aims to minimize pauses by doing most of the work concurrently with the application threads.
- Example: Use the -XX:+UseConcMarkSweepGC option.

4. **G1 Garbage Collector:**

- Aims to provide high throughput and low pause times by dividing the heap into regions.
- Example: Use the -XX:+UseG1GC option.

## Automatic GC Examples and Code Explanation

### Example 1: Basic Garbage Collection

```java
public class GCExample {
  public static void main(String[] args) {
      // Creating objects
    for (int i = 0; i < 10000; i++) {
      Object obj = new Object();
      if (i % 1000 == 0) {
        System.gc(); // Request garbage collection
        System.out.println("Garbage collection requested.");
      }
    }
    System.out.println("End of program.");
  }
}
```

Output:

```
Garbage collection requested.
Garbage collection requested.
...
End of program.
```

**Explanation:**

- **Object Creation:** Creates a large number of objects in a loop.
- **GC Request:** Calls `System.gc()` to suggest that the JVM performs garbage collection.
- **Output:** The actual GC behavior might not be observed as `System.gc()` is only a hint to the JVM.

### Example 2: Generational Garbage Collection

```java
public class GenerationalGC {
  public static void main(String[] args) {
      // Allocate objects
    for (int i = 0; i < 10000; i++) {
      allocateObject();
      if (i % 1000 == 0) {
        System.out.println("Iteration: " + i);
      }
    }
  }

  private static void allocateObject() {
    // Create objects in a method
    Object obj = new Object();
  }
}
```

Outpuut:

```
Iteration: 0
Iteration: 1000
...
```

**Explanation:**

- **Object Allocation:** Creates objects repeatedly, which will mostly be allocated in the Young Generation.
- **GC Behavior:** As the heap fills, the GC will perform minor collections to clean up the Young Generation and promote objects to the Old Generation.

## The `finalize()`

**Purpose:**
- The `finalize()` method in Java is part of the Object class and is used to perform cleanup actions on an object before it is reclaimed by the garbage collector. 
- This method is called by the garbage collector when it determines that there are no more references to the object.

**Usage:**
- **Resource Cleanup:** Typically used to release resources like file handles, network connections, or database connections.
- **Automatic Invocation:** finalize() is called automatically by the garbage collector; you do not call it directly.

**Syntax:**

```java
protected void finalize() throws Throwable {
  // Cleanup code
  super.finalize(); // Call to the superclass's finalize method
}
```

**Example:**

```java
public class FinalizeExample {
  private String resourceName;

  public FinalizeExample(String resourceName) {
    this.resourceName = resourceName;
  }

  @Override
  protected void finalize() throws Throwable {
    try {
      System.out.println("Cleaning up resources for: " + resourceName);
      // Simulate resource cleanup
    } finally {
      super.finalize(); // Ensure the superclass's finalize method is also called
    }
  }

  public static void main(String[] args) {
    FinalizeExample obj1 = new FinalizeExample("Resource1");
    FinalizeExample obj2 = new FinalizeExample("Resource2");

    obj1 = null;
    obj2 = null;

    // Suggest garbage collection
    System.gc();

    try {
      // Wait a bit for the garbage collector to do its work
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }

    System.out.println("End of program.");
  }
}
```

**Explanation:**

- **Object Creation:** Two objects are created with resources.
- **Resource Cleanup:** `finalize()` method is overridden to print a message indicating resource cleanup.
- **Garbage Collection:** The `System.gc()` method suggests that the garbage collector run, but it‚Äôs not guaranteed to do so immediately.
- **Output:** You might see messages indicating resource cleanup if the garbage collector decides to run.


Output:

```
Cleaning up resources for: Resource1
Cleaning up resources for: Resource2
End of program.
```

<hr>

<center>
<b>üí° NOTE üí°</b> 

- The use of `finalize()` is generally discouraged due to its unpredictable nature and potential performance issues.
- It‚Äôs often better to use explicit resource management with `try-with-resources` or `finally` blocks.

</center>
<hr>

<center>
<b>üí° NOTE üí°</b> 

**Do we nned to use `System.gc()` to invke the GC in java?**

- We do not need to use `System.gc()` to invoke the garbage collector and thereby call the `finalize()` method. 
- The garbage collector in Java operates automatically, and it is responsible for reclaiming memory and invoking the `finalize()` method on objects that are no longer reachable.

</center>
<hr>


[üè† Home](../../../README.md) <br/>
[üçµ Java Home](../Java.md)
