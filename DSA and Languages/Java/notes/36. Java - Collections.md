[üè† Home](../../../README.md) <br/>
[üçµ Java Home](../Java.md)

<hr/>

<h1 style="text-align: center">36. Java COllections</h1>

## Index
- [Index](#index)
- [Introduction](#introduction)
- [Hierarchy of Collection Framework](#hierarchy-of-collection-framework)
- [Built-In Methods in the Collection Class](#built-in-methods-in-the-collection-class)
- [List vs Set](#list-vs-set)
- [List vs Map](#list-vs-map)
- [Map vs Set](#map-vs-set)
- [ArrayList vs Vector](#arraylist-vs-vector)
- [ArrayList vs LinkedList](#arraylist-vs-linkedlist)
- [LinkedList vs Vector](#linkedlist-vs-vector)
- [HashSet vs TreeSet](#hashset-vs-treeset)
- [HashSet vs LinkedHashSet](#hashset-vs-linkedhashset)
- [LinkedHashSet vs TreeSet](#linkedhashset-vs-treeset)
- [HashTable vs HashMap](#hashtable-vs-hashmap)
- [HashTable vs LinkedHashMap](#hashtable-vs-linkedhashmap)
- [HashMap vs LinkedHashMap](#hashmap-vs-linkedhashmap)


<hr/>

[üîù](#index)
## Introduction

- The Java Collections Framework (JCF) was introduced in Java 2 (JDK 1.2), which was released in December 1998. 
- This framework provided a set of interfaces and classes that help manage groups of objects, making it easier to work with collections like lists, sets, and maps. 
- Before the introduction of the Collections Framework, Java developers had to rely on more primitive data structures or write their own collection classes.

[üîù](#index)
## Hierarchy of Collection Framework

![alt text](../images/collection-hierarchy.png)

[üîù](#index)
## Built-In Methods in the Collection Class

[Oracle Java Collections](https://docs.oracle.com/javase/8/docs/api/?java/util/Collections.html)

[üîù](#index)
## List vs Set

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>List</th>
      <th>Set</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Definition</td>
      <td>An ordered collection that allows duplicate elements.</td>
      <td>A collection that does not allow duplicate elements.</td>
    </tr>
    <tr>
      <td>Order</td>
      <td>Maintains the order of elements as they are inserted.</td>
      <td>
        Does not guarantee any specific order (e.g., <code>HashSet</code>), but
        <code>LinkedHashSet</code> maintains insertion order.
      </td>
    </tr>
    <tr>
      <td>Duplicates</td>
      <td>Allows duplicate elements.</td>
      <td>Does not allow duplicate elements.</td>
    </tr>
    <tr>
      <td>Implementation Classes</td>
      <td>
        <code>ArrayList</code>, <code>LinkedList</code>, <code>Vector</code>,
        <code>Stack</code>
      </td>
      <td>
        <code>HashSet</code>, <code>LinkedHashSet</code>, <code>TreeSet</code>
      </td>
    </tr>
    <tr>
      <td>Access by Index</td>
      <td>
        Provides access to elements by index (e.g.,
        <code>list.get(index)</code>).
      </td>
      <td>Does not support access by index.</td>
    </tr>
    <tr>
      <td>Performance (Insertion)</td>
      <td>
        Generally, <code>ArrayList</code> provides constant time insertion,
        while <code>LinkedList</code> provides constant time insertion at the
        beginning or end.
      </td>
      <td>
        Generally, <code>HashSet</code> provides constant time insertion,
        <code>LinkedHashSet</code> provides constant time insertion, and
        <code>TreeSet</code> provides logarithmic time insertion.
      </td>
    </tr>
    <tr>
      <td>Performance (Search)</td>
      <td>
        <code>ArrayList</code> provides linear time search, while
        <code>LinkedList</code> provides linear time search.
      </td>
      <td>
        <code>HashSet</code> provides constant time search,
        <code>TreeSet</code> provides logarithmic time search, and
        <code>LinkedHashSet</code> provides constant time search.
      </td>
    </tr>
    <tr>
      <td>Performance (Removal)</td>
      <td>
        <code>ArrayList</code> provides linear time removal, while
        <code>LinkedList</code> provides constant time removal if the node is
        known.
      </td>
      <td>
        <code>HashSet</code> provides constant time removal,
        <code>TreeSet</code> provides logarithmic time removal, and
        <code>LinkedHashSet</code> provides constant time removal.
      </td>
    </tr>
    <tr>
      <td>Use Cases</td>
      <td>
        Suitable for scenarios where you need to maintain insertion order or
        access elements by index.
      </td>
      <td>
        Suitable for scenarios where uniqueness of elements is important, and
        ordering is not a concern (or you need a specific ordering).
      </td>
    </tr>
    <tr>
      <td>Null Elements</td>
      <td>Allows null elements.</td>
      <td>
        Allows null elements in <code>HashSet</code> and
        <code>LinkedHashSet</code>, but not in <code>TreeSet</code>.
      </td>
    </tr>
    <tr>
      <td>Thread-Safety</td>
      <td>
        <code>ArrayList</code> and <code>LinkedList</code> are not thread-safe.
        <code>Vector</code> is synchronized and thread-safe.
      </td>
      <td>
        <code>HashSet</code>, <code>LinkedHashSet</code>, and
        <code>TreeSet</code> are not thread-safe.
      </td>
    </tr>
    <tr>
      <td>Examples</td>
      <td><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code></td>
      <td><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();</code></td>
    </tr>
  </tbody>
</table>


[üîù](#index)
## List vs Map

<table border="1">
  <thead>
    <tr>
      <th>Feature</th>
      <th>List</th>
      <th>Map</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Definition</td>
      <td>An ordered collection that allows duplicate elements.</td>
      <td>
        An object that maps keys to values, with no duplicate keys allowed.
      </td>
    </tr>
    <tr>
      <td>Order</td>
      <td>Maintains the order of elements as they are inserted.</td>
      <td>
        Order of elements depends on the implementation (e.g.,
        <code>HashMap</code> does not guarantee order, while
        <code>LinkedHashMap</code> maintains insertion order and
        <code>TreeMap</code> maintains natural or specified order of keys).
      </td>
    </tr>
    <tr>
      <td>Duplicates</td>
      <td>Allows duplicate elements.</td>
      <td>Does not allow duplicate keys. Values can be duplicated.</td>
    </tr>
    <tr>
      <td>Implementation Classes</td>
      <td>
        <code>ArrayList</code>, <code>LinkedList</code>, <code>Vector</code>,
        <code>Stack</code>
      </td>
      <td>
        <code>HashMap</code>, <code>LinkedHashMap</code>, <code>TreeMap</code>,
        <code>Hashtable</code>
      </td>
    </tr>
    <tr>
      <td>Access</td>
      <td>
        Provides access to elements by index (e.g.,
        <code>list.get(index)</code>).
      </td>
      <td>
        Provides access to values by key (e.g., <code>map.get(key)</code>).
      </td>
    </tr>
    <tr>
      <td>Performance (Insertion)</td>
      <td>
        Generally, <code>ArrayList</code> provides constant time insertion,
        while <code>LinkedList</code> provides constant time insertion at the
        beginning or end.
      </td>
      <td>
        <code>HashMap</code> provides constant time insertion,
        <code>LinkedHashMap</code> provides constant time insertion, and
        <code>TreeMap</code> provides logarithmic time insertion.
      </td>
    </tr>
    <tr>
      <td>Performance (Search)</td>
      <td>
        <code>ArrayList</code> provides linear time search, while
        <code>LinkedList</code> provides linear time search.
      </td>
      <td>
        Search time is constant for <code>HashMap</code>, logarithmic for
        <code>TreeMap</code>, and constant for <code>LinkedHashMap</code>.
      </td>
    </tr>
    <tr>
      <td>Performance (Removal)</td>
      <td>
        <code>ArrayList</code> provides linear time removal, while
        <code>LinkedList</code> provides constant time removal if the node is
        known.
      </td>
      <td>
        Removal time is constant for <code>HashMap</code>, logarithmic for
        <code>TreeMap</code>, and constant for <code>LinkedHashMap</code>.
      </td>
    </tr>
    <tr>
      <td>Use Cases</td>
      <td>
        Suitable for scenarios where you need to maintain insertion order or
        access elements by index.
      </td>
      <td>
        Suitable for scenarios where you need to associate keys with values and
        retrieve values based on keys.
      </td>
    </tr>
    <tr>
      <td>Null Elements</td>
      <td>Allows null elements.</td>
      <td>
        Allows null keys and values in <code>HashMap</code> and
        <code>LinkedHashMap</code>, but not in <code>TreeMap</code> (null keys
        are not allowed in <code>TreeMap</code>).
      </td>
    </tr>
    <tr>
      <td>Thread-Safety</td>
      <td>
        <code>ArrayList</code> and <code>LinkedList</code> are not thread-safe.
        <code>Vector</code> is synchronized and thread-safe.
      </td>
      <td>
        <code>HashMap</code>, <code>LinkedHashMap</code>, and
        <code>TreeMap</code> are not thread-safe. <code>Hashtable</code> is
        synchronized and thread-safe.
      </td>
    </tr>
    <tr>
      <td>Examples</td>
      <td><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code></td>
      <td>
        <code>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</code>
      </td>
    </tr>
  </tbody>
</table>


[üîù](#index)
## Map vs Set

<table border="1">
  <thead>
    <tr>
      <th>Feature</th>
      <th>Map</th>
      <th>Set</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Definition</td>
      <td>
        An object that maps keys to values, with no duplicate keys allowed.
      </td>
      <td>A collection that does not allow duplicate elements.</td>
    </tr>
    <tr>
      <td>Order</td>
      <td>
        Order of elements depends on the implementation (e.g.,
        <code>HashMap</code> does not guarantee order, while
        <code>LinkedHashMap</code> maintains insertion order and
        <code>TreeMap</code> maintains natural or specified order of keys).
      </td>
      <td>
        Does not guarantee any specific order (e.g., <code>HashSet</code>), but
        <code>LinkedHashSet</code> maintains insertion order.
      </td>
    </tr>
    <tr>
      <td>Duplicates</td>
      <td>Does not allow duplicate keys. Values can be duplicated.</td>
      <td>Does not allow duplicate elements.</td>
    </tr>
    <tr>
      <td>Implementation Classes</td>
      <td>
        <code>HashMap</code>, <code>LinkedHashMap</code>, <code>TreeMap</code>,
        <code>Hashtable</code>
      </td>
      <td>
        <code>HashSet</code>, <code>LinkedHashSet</code>, <code>TreeSet</code>
      </td>
    </tr>
    <tr>
      <td>Access</td>
      <td>
        Provides access to values by key (e.g., <code>map.get(key)</code>).
      </td>
      <td>Does not support access by index or key.</td>
    </tr>
    <tr>
      <td>Performance (Insertion)</td>
      <td>
        <code>HashMap</code> provides constant time insertion,
        <code>LinkedHashMap</code> provides constant time insertion, and
        <code>TreeMap</code> provides logarithmic time insertion.
      </td>
      <td>
        Generally, <code>HashSet</code> provides constant time insertion,
        <code>LinkedHashSet</code> provides constant time insertion, and
        <code>TreeSet</code> provides logarithmic time insertion.
      </td>
    </tr>
    <tr>
      <td>Performance (Search)</td>
      <td>
        Search time is constant for <code>HashMap</code>, logarithmic for
        <code>TreeMap</code>, and constant for <code>LinkedHashMap</code>.
      </td>
      <td>
        <code>HashSet</code> provides constant time search,
        <code>TreeSet</code> provides logarithmic time search, and
        <code>LinkedHashSet</code> provides constant time search.
      </td>
    </tr>
    <tr>
      <td>Performance (Removal)</td>
      <td>
        Removal time is constant for <code>HashMap</code>, logarithmic for
        <code>TreeMap</code>, and constant for <code>LinkedHashMap</code>.
      </td>
      <td>
        <code>HashSet</code> provides constant time removal,
        <code>TreeSet</code> provides logarithmic time removal, and
        <code>LinkedHashSet</code> provides constant time removal.
      </td>
    </tr>
    <tr>
      <td>Use Cases</td>
      <td>
        Suitable for scenarios where you need to associate keys with values and
        retrieve values based on keys.
      </td>
      <td>
        Suitable for scenarios where uniqueness of elements is important, and
        ordering is not a concern (or you need a specific ordering).
      </td>
    </tr>
    <tr>
      <td>Null Elements</td>
      <td>
        Allows null keys and values in <code>HashMap</code> and
        <code>LinkedHashMap</code>, but not in <code>TreeMap</code> (null keys
        are not allowed in <code>TreeMap</code>).
      </td>
      <td>
        Allows null elements in <code>HashSet</code> and
        <code>LinkedHashSet</code>, but not in <code>TreeSet</code>.
      </td>
    </tr>
    <tr>
      <td>Thread-Safety</td>
      <td>
        <code>HashMap</code>, <code>LinkedHashMap</code>, and
        <code>TreeMap</code> are not thread-safe. <code>Hashtable</code> is
        synchronized and thread-safe.
      </td>
      <td>
        <code>HashSet</code>, <code>LinkedHashSet</code>, and
        <code>TreeSet</code> are not thread-safe.
      </td>
    </tr>
    <tr>
      <td>Examples</td>
      <td>
        <code>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</code>
      </td>
      <td><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();</code></td>
    </tr>
  </tbody>
</table>


[üîù](#index)
## ArrayList vs Vector

<table border="1">
  <thead>
    <tr>
      <th>Feature</th>
      <th>ArrayList</th>
      <th>Vector</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Definition</td>
      <td>
        A resizable array implementation of the <code>List</code> interface.
      </td>
      <td>
        A resizable array implementation of the <code>List</code> interface with
        synchronized methods.
      </td>
    </tr>
    <tr>
      <td>Synchronization</td>
      <td>Not synchronized. It is not thread-safe.</td>
      <td>Synchronized. It is thread-safe.</td>
    </tr>
    <tr>
      <td>Performance</td>
      <td>
        Generally faster than <code>Vector</code> because it is not
        synchronized.
      </td>
      <td>
        Generally slower than <code>ArrayList</code> due to synchronization
        overhead.
      </td>
    </tr>
    <tr>
      <td>Growth Policy</td>
      <td>Increases size by 50% when the array is full.</td>
      <td>Increases size by doubling when the array is full.</td>
    </tr>
    <tr>
      <td>Legacy</td>
      <td>
        Introduced in JDK 1.2 as part of the <code>Collections Framework</code>.
      </td>
      <td>Introduced in JDK 1.0 and part of the original Java version.</td>
    </tr>
    <tr>
      <td>Methods</td>
      <td>Does not include methods that are specific to legacy classes.</td>
      <td>
        Includes legacy methods such as <code>elements()</code> that are not
        present in <code>ArrayList</code>.
      </td>
    </tr>
    <tr>
      <td>Use Case</td>
      <td>
        Preferred for most applications due to better performance and lack of
        synchronization overhead.
      </td>
      <td>
        Used when thread safety is required and no external synchronization is
        desired.
      </td>
    </tr>
    <tr>
      <td>Examples</td>
      <td>
        <code>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</code>
      </td>
      <td><code>Vector&lt;String&gt; vector = new Vector&lt;&gt;();</code></td>
    </tr>
  </tbody>
</table>


[üîù](#index)
## ArrayList vs LinkedList

<table border="1">
  <thead>
    <tr>
      <th>Feature</th>
      <th>ArrayList</th>
      <th>LinkedList</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Definition</td>
      <td>
        A resizable array implementation of the <code>List</code> interface.
      </td>
      <td>
        A doubly linked list implementation of the <code>List</code> interface.
      </td>
    </tr>
    <tr>
      <td>Underlying Data Structure</td>
      <td>Uses a dynamic array to store elements.</td>
      <td>Uses a doubly linked list to store elements.</td>
    </tr>
    <tr>
      <td>Performance (Access)</td>
      <td>
        Provides fast random access to elements (constant time
        <code>get(index)</code>).
      </td>
      <td>
        Provides slower random access (linear time <code>get(index)</code>), but
        fast access to neighboring elements.
      </td>
    </tr>
    <tr>
      <td>Performance (Insertion/Removal)</td>
      <td>
        Fast at the end of the list (constant time), but slow for
        insertions/removals in the middle (linear time).
      </td>
      <td>
        Fast insertions and removals at the beginning or end (constant time),
        but slow for insertions/removals in the middle (linear time).
      </td>
    </tr>
    <tr>
      <td>Memory Usage</td>
      <td>Uses less memory per element (just the array overhead).</td>
      <td>
        Uses more memory per element (additional storage for node references).
      </td>
    </tr>
    <tr>
      <td>Resize Operation</td>
      <td>
        Automatically resizes the array when needed (requires array copying).
      </td>
      <td>
        Does not require resizing as it grows dynamically (no array copying).
      </td>
    </tr>
    <tr>
      <td>Thread-Safety</td>
      <td>Not synchronized. It is not thread-safe.</td>
      <td>Not synchronized. It is not thread-safe.</td>
    </tr>
    <tr>
      <td>Use Case</td>
      <td>
        Preferred when frequent access to elements by index is required and when
        memory overhead needs to be minimized.
      </td>
      <td>
        Preferred when frequent insertions and deletions are required,
        especially at the beginning or end of the list.
      </td>
    </tr>
    <tr>
      <td>Examples</td>
      <td>
        <code
          >ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();</code
        >
      </td>
      <td>
        <code
          >LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();</code
        >
      </td>
    </tr>
  </tbody>
</table>


[üîù](#index)
## LinkedList vs Vector

<table border="1">
  <thead>
    <tr>
      <th>Feature</th>
      <th>LinkedList</th>
      <th>Vector</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Definition</td>
      <td>
        A doubly linked list implementation of the <code>List</code> interface.
      </td>
      <td>
        A resizable array implementation of the <code>List</code> interface with
        synchronized methods.
      </td>
    </tr>
    <tr>
      <td>Underlying Data Structure</td>
      <td>Uses a doubly linked list to store elements.</td>
      <td>Uses a dynamic array to store elements.</td>
    </tr>
    <tr>
      <td>Performance (Access)</td>
      <td>
        Provides slower random access (linear time <code>get(index)</code>), but
        fast access to neighboring elements.
      </td>
      <td>
        Provides fast random access (constant time <code>get(index)</code>).
      </td>
    </tr>
    <tr>
      <td>Performance (Insertion/Removal)</td>
      <td>
        Fast insertions and removals at the beginning or end (constant time),
        but slower in the middle (linear time).
      </td>
      <td>
        Fast at the end of the list (constant time), but slow for
        insertions/removals in the middle (linear time).
      </td>
    </tr>
    <tr>
      <td>Memory Usage</td>
      <td>
        Uses more memory per element (additional storage for node references).
      </td>
      <td>Uses less memory per element (just the array overhead).</td>
    </tr>
    <tr>
      <td>Synchronization</td>
      <td>Not synchronized. It is not thread-safe.</td>
      <td>Synchronized. It is thread-safe.</td>
    </tr>
    <tr>
      <td>Resize Operation</td>
      <td>
        Does not require resizing as it grows dynamically (no array copying).
      </td>
      <td>
        Automatically resizes the array when needed (requires array copying).
      </td>
    </tr>
    <tr>
      <td>Use Case</td>
      <td>
        Preferred when frequent insertions and deletions are required,
        especially at the beginning or end of the list.
      </td>
      <td>
        Preferred when you need a thread-safe implementation and when the
        performance overhead of synchronization is acceptable.
      </td>
    </tr>
    <tr>
      <td>Examples</td>
      <td>
        <code
          >LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();</code
        >
      </td>
      <td><code>Vector&lt;String&gt; vector = new Vector&lt;&gt;();</code></td>
    </tr>
  </tbody>
</table>


[üîù](#index)
## HashSet vs TreeSet

<table border="1">
  <thead>
    <tr>
      <th>Feature</th>
      <th>HashSet</th>
      <th>TreeSet</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Definition</td>
      <td>A set implementation that uses a hash table for storage.</td>
      <td>A set implementation that uses a Red-Black tree for storage.</td>
    </tr>
    <tr>
      <td>Ordering</td>
      <td>
        Does not guarantee any specific order of elements. The order is based on
        the hash codes of the elements.
      </td>
      <td>
        Maintains elements in a sorted order according to their natural ordering
        or a specified comparator.
      </td>
    </tr>
    <tr>
      <td>Performance (Insertion/Deletion)</td>
      <td>
        Provides constant time complexity (O(1)) for basic operations (add,
        remove, contains) assuming a good hash function.
      </td>
      <td>
        Provides logarithmic time complexity (O(log n)) for basic operations
        (add, remove, contains) due to the underlying Red-Black tree.
      </td>
    </tr>
    <tr>
      <td>Null Elements</td>
      <td>Allows a single null element.</td>
      <td>
        Allows a single null element if the natural ordering or comparator
        allows it (but the comparator must handle null values). Generally, it is
        better to avoid nulls in a <code>TreeSet</code>.
      </td>
    </tr>
    <tr>
      <td>Memory Usage</td>
      <td>
        Generally uses less memory compared to <code>TreeSet</code> due to the
        hash table overhead.
      </td>
      <td>
        Generally uses more memory due to the Red-Black tree structure and
        associated node references.
      </td>
    </tr>
    <tr>
      <td>Thread-Safety</td>
      <td>Not synchronized. It is not thread-safe.</td>
      <td>Not synchronized. It is not thread-safe.</td>
    </tr>
    <tr>
      <td>Use Case</td>
      <td>
        Preferred when you need a set with fast operations and don't need sorted
        order.
      </td>
      <td>
        Preferred when you need a set that maintains elements in a sorted order.
      </td>
    </tr>
    <tr>
      <td>Examples</td>
      <td>
        <code>HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;();</code>
      </td>
      <td>
        <code>TreeSet&lt;String&gt; treeSet = new TreeSet&lt;&gt;();</code>
      </td>
    </tr>
  </tbody>
</table>


[üîù](#index)
## HashSet vs LinkedHashSet

<table border="1">
  <thead>
    <tr>
      <th>Feature</th>
      <th>HashSet</th>
      <th>LinkedHashSet</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Definition</td>
      <td>A set implementation that uses a hash table for storage.</td>
      <td>
        A set implementation that uses a hash table and a linked list for
        storage, preserving insertion order.
      </td>
    </tr>
    <tr>
      <td>Ordering</td>
      <td>
        Does not guarantee any specific order of elements. The order is based on
        the hash codes of the elements.
      </td>
      <td>
        Maintains elements in the order they were inserted, due to the linked
        list component.
      </td>
    </tr>
    <tr>
      <td>Performance (Insertion/Deletion)</td>
      <td>
        Provides constant time complexity (O(1)) for basic operations (add,
        remove, contains) assuming a good hash function.
      </td>
      <td>
        Provides slightly slower constant time complexity (O(1)) for basic
        operations compared to <code>HashSet</code> due to additional overhead
        of maintaining the linked list.
      </td>
    </tr>
    <tr>
      <td>Memory Usage</td>
      <td>
        Generally uses less memory compared to
        <code>LinkedHashSet</code> because it only uses a hash table.
      </td>
      <td>
        Uses more memory due to the additional overhead of the linked list used
        to maintain insertion order.
      </td>
    </tr>
    <tr>
      <td>Null Elements</td>
      <td>Allows a single null element.</td>
      <td>Allows a single null element.</td>
    </tr>
    <tr>
      <td>Thread-Safety</td>
      <td>Not synchronized. It is not thread-safe.</td>
      <td>Not synchronized. It is not thread-safe.</td>
    </tr>
    <tr>
      <td>Use Case</td>
      <td>
        Preferred when you need a set with fast operations and do not require
        element ordering.
      </td>
      <td>
        Preferred when you need a set that maintains the order of elements as
        they were inserted, with slightly higher memory overhead.
      </td>
    </tr>
    <tr>
      <td>Examples</td>
      <td>
        <code>HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;();</code>
      </td>
      <td>
        <code
          >LinkedHashSet&lt;String&gt; linkedHashSet = new
          LinkedHashSet&lt;&gt;();</code
        >
      </td>
    </tr>
  </tbody>
</table>


[üîù](#index)
## LinkedHashSet vs TreeSet

<table border="1">
  <thead>
    <tr>
      <th>Feature</th>
      <th>LinkedHashSet</th>
      <th>TreeSet</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Definition</td>
      <td>
        A set implementation that uses a hash table and a linked list for
        storage, preserving insertion order.
      </td>
      <td>
        A set implementation that uses a Red-Black tree for storage, maintaining
        a sorted order.
      </td>
    </tr>
    <tr>
      <td>Ordering</td>
      <td>
        Maintains elements in the order they were inserted, due to the linked
        list component.
      </td>
      <td>
        Maintains elements in a sorted order according to their natural ordering
        or a specified comparator.
      </td>
    </tr>
    <tr>
      <td>Performance (Insertion/Deletion)</td>
      <td>
        Provides slightly slower constant time complexity (O(1)) for basic
        operations compared to <code>HashSet</code> due to the linked list
        overhead.
      </td>
      <td>
        Provides logarithmic time complexity (O(log n)) for basic operations
        (add, remove, contains) due to the Red-Black tree structure.
      </td>
    </tr>
    <tr>
      <td>Memory Usage</td>
      <td>
        Uses more memory than <code>HashSet</code> due to the additional
        overhead of the linked list used to maintain insertion order.
      </td>
      <td>
        Uses more memory than <code>LinkedHashSet</code> due to the Red-Black
        tree structure and additional node references.
      </td>
    </tr>
    <tr>
      <td>Null Elements</td>
      <td>Allows a single null element.</td>
      <td>
        Does not allow null elements, as the tree requires natural ordering or a
        comparator that cannot handle null.
      </td>
    </tr>
    <tr>
      <td>Thread-Safety</td>
      <td>Not synchronized. It is not thread-safe.</td>
      <td>Not synchronized. It is not thread-safe.</td>
    </tr>
    <tr>
      <td>Use Case</td>
      <td>
        Preferred when you need a set that maintains the insertion order of
        elements with minimal performance overhead.
      </td>
      <td>
        Preferred when you need a set that maintains a sorted order of elements,
        and the order is important.
      </td>
    </tr>
    <tr>
      <td>Examples</td>
      <td>
        <code
          >LinkedHashSet&lt;String&gt; linkedHashSet = new
          LinkedHashSet&lt;&gt;();</code
        >
      </td>
      <td>
        <code>TreeSet&lt;String&gt; treeSet = new TreeSet&lt;&gt;();</code>
      </td>
    </tr>
  </tbody>
</table>


[üîù](#index)
## HashTable vs HashMap

<table border="1">
  <thead>
    <tr>
      <th>Feature</th>
      <th>Hashtable</th>
      <th>HashMap</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Definition</td>
      <td>
        A legacy class that implements a synchronized hash table for key-value
        pairs.
      </td>
      <td>
        A modern class that implements an unsynchronized hash table for
        key-value pairs.
      </td>
    </tr>
    <tr>
      <td>Synchronization</td>
      <td>
        Synchronized. It is thread-safe, meaning multiple threads can access it
        concurrently without corrupting data.
      </td>
      <td>
        Not synchronized. It is not thread-safe and requires external
        synchronization for use in concurrent contexts.
      </td>
    </tr>
    <tr>
      <td>Null Keys/Values</td>
      <td>Does not allow null keys or null values.</td>
      <td>Allows one null key and multiple null values.</td>
    </tr>
    <tr>
      <td>Performance</td>
      <td>Generally slower due to synchronization overhead.</td>
      <td>Generally faster due to lack of synchronization overhead.</td>
    </tr>
    <tr>
      <td>Legacy Status</td>
      <td>Introduced in JDK 1.0. Considered a legacy class.</td>
      <td>
        Introduced in JDK 1.2 as part of the Collections Framework. Not a legacy
        class.
      </td>
    </tr>
    <tr>
      <td>Thread-Safety</td>
      <td>Built-in thread safety due to synchronized methods.</td>
      <td>
        Not thread-safe. Use <code>Collections.synchronizedMap</code> or
        <code>ConcurrentHashMap</code> for thread-safe operations.
      </td>
    </tr>
    <tr>
      <td>Iterator</td>
      <td>The iterator is not fail-fast.</td>
      <td>
        The iterator is fail-fast, meaning it will throw a
        <code>ConcurrentModificationException</code> if the map is modified
        while iterating.
      </td>
    </tr>
    <tr>
      <td>Use Case</td>
      <td>
        Suitable for legacy code that requires a thread-safe implementation of a
        hash table.
      </td>
      <td>
        Preferred for most modern applications due to better performance and
        support for null values.
      </td>
    </tr>
    <tr>
      <td>Examples</td>
      <td>
        <code
          >Hashtable&lt;String, Integer&gt; hashtable = new
          Hashtable&lt;&gt;();</code
        >
      </td>
      <td>
        <code
          >HashMap&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;();</code
        >
      </td>
    </tr>
  </tbody>
</table>


[üîù](#index)
## HashTable vs LinkedHashMap

<table border="1">
  <thead>
    <tr>
      <th>Feature</th>
      <th>Hashtable</th>
      <th>LinkedHashMap</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Definition</td>
      <td>
        A legacy class that implements a synchronized hash table for key-value
        pairs.
      </td>
      <td>
        A hash table and linked list implementation of the
        <code>Map</code> interface that maintains insertion order.
      </td>
    </tr>
    <tr>
      <td>Synchronization</td>
      <td>
        Synchronized. It is thread-safe, meaning multiple threads can access it
        concurrently without corrupting data.
      </td>
      <td>
        Not synchronized. It is not thread-safe and requires external
        synchronization for use in concurrent contexts.
      </td>
    </tr>
    <tr>
      <td>Null Keys/Values</td>
      <td>Does not allow null keys or null values.</td>
      <td>Allows one null key and multiple null values.</td>
    </tr>
    <tr>
      <td>Ordering</td>
      <td>
        Does not guarantee any specific order of elements. The order is based on
        the hash codes of the elements.
      </td>
      <td>
        Maintains elements in the order they were inserted, due to the linked
        list component.
      </td>
    </tr>
    <tr>
      <td>Performance</td>
      <td>Generally slower due to synchronization overhead.</td>
      <td>
        Provides slightly slower performance than <code>HashMap</code> due to
        additional overhead of maintaining the linked list, but generally faster
        than <code>Hashtable</code>.
      </td>
    </tr>
    <tr>
      <td>Legacy Status</td>
      <td>Introduced in JDK 1.0. Considered a legacy class.</td>
      <td>
        Introduced in JDK 1.2 as part of the Collections Framework. Not a legacy
        class.
      </td>
    </tr>
    <tr>
      <td>Thread-Safety</td>
      <td>Built-in thread safety due to synchronized methods.</td>
      <td>
        Not thread-safe. Use <code>Collections.synchronizedMap</code> for
        thread-safe operations.
      </td>
    </tr>
    <tr>
      <td>Iterator</td>
      <td>The iterator is not fail-fast.</td>
      <td>
        The iterator is fail-fast, meaning it will throw a
        <code>ConcurrentModificationException</code> if the map is modified
        while iterating.
      </td>
    </tr>
    <tr>
      <td>Use Case</td>
      <td>
        Suitable for legacy code that requires a thread-safe implementation of a
        hash table.
      </td>
      <td>
        Preferred when you need a map that maintains insertion order with better
        performance than <code>Hashtable</code>.
      </td>
    </tr>
    <tr>
      <td>Examples</td>
      <td>
        <code
          >Hashtable&lt;String, Integer&gt; hashtable = new
          Hashtable&lt;&gt;();</code
        >
      </td>
      <td>
        <code
          >LinkedHashMap&lt;String, Integer&gt; linkedHashMap = new
          LinkedHashMap&lt;&gt;();</code
        >
      </td>
    </tr>
  </tbody>
</table>


[üîù](#index)
## HashMap vs LinkedHashMap

<table border="1">
  <thead>
    <tr>
      <th>Feature</th>
      <th>HashMap</th>
      <th>LinkedHashMap</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Definition</td>
      <td>A hash table-based implementation of the <code>Map</code> interface.</td>
      <td>A hash table and linked list implementation of the <code>Map</code> interface that maintains insertion order.</td>
    </tr>
    <tr>
      <td>Ordering</td>
      <td>Does not guarantee any specific order of elements. The order is based on the hash codes of the elements.</td>
      <td>Maintains elements in the order they were inserted, due to the linked list component.</td>
    </tr>
    <tr>
      <td>Performance (Insertion/Deletion)</td>
      <td>Provides constant time complexity (O(1)) for basic operations (add, remove, contains) assuming a good hash function.</td>
      <td>Provides slightly slower constant time complexity (O(1)) for basic operations compared to <code>HashMap</code> due to additional overhead of maintaining the linked list.</td>
    </tr>
    <tr>
      <td>Memory Usage</td>
      <td>Generally uses less memory compared to <code>LinkedHashMap</code> because it only uses a hash table.</td>
      <td>Uses more memory due to the additional overhead of the linked list used to maintain insertion order.</td>
    </tr>
    <tr>
      <td>Null Keys/Values</td>
      <td>Allows one null key and multiple null values.</td>
      <td>Allows one null key and multiple null values.</td>
    </tr>
    <tr>
      <td>Thread-Safety</td>
      <td>Not synchronized. It is not thread-safe and requires external synchronization for use in concurrent contexts.</td>
      <td>Not synchronized. It is not thread-safe and requires external synchronization for use in concurrent contexts.</td>
    </tr>
    <tr>
      <td>Iterator</td>
      <td>The iterator is fail-fast, meaning it will throw a <code>ConcurrentModificationException</code> if the map is modified while iterating.</td>
      <td>The iterator is fail-fast, meaning it will throw a <code>ConcurrentModificationException</code> if the map is modified while iterating.</td>
    </tr>
    <tr>
      <td>Use Case</td>
      <td>Preferred when you do not need to maintain the order of elements and want a map with better performance.</td>
      <td>Preferred when you need a map that maintains the order of elements as they were inserted, with slightly higher memory overhead.</td>
    </tr>
    <tr>
      <td>Examples</td>
      <td><code>HashMap&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;();</code></td>
      <td><code>LinkedHashMap&lt;String, Integer&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();</code></td>
    </tr>
  </tbody>
</table>



<hr/>

[üè† Home](../../../README.md) <br/>
[üçµ Java Home](../Java.md)