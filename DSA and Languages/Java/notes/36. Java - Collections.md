[üè† Home](../../../README.md) <br/>
[üçµ Java Home](../Java.md)

<hr/>

<h1 style="text-align: center">36. Java COllections</h1>

## Index
- [Index](#index)
- [Introduction](#introduction)
- [Hierarchy of Collection Framework](#hierarchy-of-collection-framework)
- [Built-In Methods in the Collection Class](#built-in-methods-in-the-collection-class)
  - [1. `addAll()` Method](#1-addall-method)
  - [2. `asLifoQueue()` Method](#2-aslifoqueue-method)
  - [3. `binarySearch()` Method](#3-binarysearch-method)
  - [4. `copy()`](#4-copy)
  - [5. `disjoint()`](#5-disjoint)
  - [6. `fill()`](#6-fill)
  - [7. `frequency()`](#7-frequency)
  - [8. `indexOfSubList()`](#8-indexofsublist)
  - [9. `lastIndexOfSubList()`](#9-lastindexofsublist)
  - [10. `list()`](#10-list)
  - [11. `max()`](#11-max)
  - [12. `min()`](#12-min)
  - [13. `nCopies()`](#13-ncopies)
  - [14. `replaceAll()`](#14-replaceall)
  - [15. `reverse()`](#15-reverse)
  - [16. `rotate()`](#16-rotate)
  - [17. `shuffle()`](#17-shuffle)
  - [18. `singleton()`](#18-singleton)
  - [18. `sort()`](#18-sort)
  - [19. `swap()`](#19-swap)
  - [20. `unmodifiableList()`](#20-unmodifiablelist)
- [List vs Set](#list-vs-set)
- [List vs Map](#list-vs-map)
- [Map vs Set](#map-vs-set)
- [ArrayList vs Vector](#arraylist-vs-vector)
- [ArrayList vs LinkedList](#arraylist-vs-linkedlist)
- [LinkedList vs Vector](#linkedlist-vs-vector)
- [HashSet vs TreeSet](#hashset-vs-treeset)
- [HashSet vs LinkedHashSet](#hashset-vs-linkedhashset)
- [LinkedHashSet vs TreeSet](#linkedhashset-vs-treeset)
- [HashTable vs HashMap](#hashtable-vs-hashmap)
- [HashTable vs LinkedHashMap](#hashtable-vs-linkedhashmap)
- [HashMap vs LinkedHashMap](#hashmap-vs-linkedhashmap)


<hr/>

[‚¨ÜÔ∏è Back to Top ‚¨ÜÔ∏è](#index)
## Introduction

- The Java Collections Framework (JCF) was introduced in Java 2 (JDK 1.2), which was released in December 1998. 
- This framework provided a set of interfaces and classes that help manage groups of objects, making it easier to work with collections like lists, sets, and maps. 
- Before the introduction of the Collections Framework, Java developers had to rely on more primitive data structures or write their own collection classes.

[‚¨ÜÔ∏è Back to Top ‚¨ÜÔ∏è](#index)
## Hierarchy of Collection Framework

![alt text](../images/collection-hierarchy.png)

[‚¨ÜÔ∏è Back to Top ‚¨ÜÔ∏è](#index)
## Built-In Methods in the Collection Class

[Oracle Java Collections](https://docs.oracle.com/javase/8/docs/api/?java/util/Collections.html)

<table border="1">
  <thead>
    <tr>
      <th>Method Name</th>
      <th>Return Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>addAll(Collection&lt;? super T&gt; c, T... elements)</td>
      <td>boolean</td>
      <td>Adds all of the specified elements to the specified collection.</td>
    </tr>
    <tr>
      <td>asLifoQueue(Deque&lt;T&gt; deque)</td>
      <td>Queue&lt;T&gt;</td>
      <td>Returns a view of a Deque as a Last-In-First-Out (LIFO) Queue.</td>
    </tr>
    <tr>
      <td>binarySearch(List&lt;? extends T&gt; list, T key)</td>
      <td>int</td>
      <td>
        Searches the specified list for the specified object using binary
        search.
      </td>
    </tr>
    <tr>
      <td>copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</td>
      <td>void</td>
      <td>Copies all of the elements from one list into another.</td>
    </tr>
    <tr>
      <td>disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2)</td>
      <td>boolean</td>
      <td>
        Returns true if the two specified collections have no elements in
        common.
      </td>
    </tr>
    <tr>
      <td>emptyList()</td>
      <td>List&lt;T&gt;</td>
      <td>Returns an empty, immutable list.</td>
    </tr>
    <tr>
      <td>emptyMap()</td>
      <td>Map&lt;K, V&gt;</td>
      <td>Returns an empty, immutable map.</td>
    </tr>
    <tr>
      <td>emptySet()</td>
      <td>Set&lt;T&gt;</td>
      <td>Returns an empty, immutable set.</td>
    </tr>
    <tr>
      <td>fill(List&lt;? super T&gt; list, T obj)</td>
      <td>void</td>
      <td>
        Replaces all of the elements of the specified list with the specified
        element.
      </td>
    </tr>
    <tr>
      <td>frequency(Collection&lt;?&gt; c, Object o)</td>
      <td>int</td>
      <td>
        Returns the number of occurrences of the specified element in the
        specified collection.
      </td>
    </tr>
    <tr>
      <td>indexOfSubList(List&lt;?&gt; source, List&lt;?&gt; target)</td>
      <td>int</td>
      <td>
        Returns the starting position of the first occurrence of the specified
        target list within the source list.
      </td>
    </tr>
    <tr>
      <td>lastIndexOfSubList(List&lt;?&gt; source, List&lt;?&gt; target)</td>
      <td>int</td>
      <td>
        Returns the starting position of the last occurrence of the specified
        target list within the source list.
      </td>
    </tr>
    <tr>
      <td>list(Enumeration&lt;T&gt; e)</td>
      <td>ArrayList&lt;T&gt;</td>
      <td>
        Returns an ArrayList containing the elements returned by the specified
        enumeration.
      </td>
    </tr>
    <tr>
      <td>max(Collection&lt;? extends T&gt; coll)</td>
      <td>T</td>
      <td>
        Returns the maximum element of the given collection, according to the
        natural ordering of its elements.
      </td>
    </tr>
    <tr>
      <td>min(Collection&lt;? extends T&gt; coll)</td>
      <td>T</td>
      <td>
        Returns the minimum element of the given collection, according to the
        natural ordering of its elements.
      </td>
    </tr>
    <tr>
      <td>nCopies(int n, T o)</td>
      <td>List&lt;T&gt;</td>
      <td>
        Returns an immutable list consisting of n copies of the specified
        object.
      </td>
    </tr>
    <tr>
      <td>replaceAll(List&lt;T&gt; list, T oldVal, T newVal)</td>
      <td>boolean</td>
      <td>
        Replaces all occurrences of one specified value in a list with another.
      </td>
    </tr>
    <tr>
      <td>reverse(List&lt;?&gt; list)</td>
      <td>void</td>
      <td>Reverses the order of the elements in the specified list.</td>
    </tr>
    <tr>
      <td>shuffle(List&lt;?&gt; list)</td>
      <td>void</td>
      <td>
        Randomly permutes the specified list using a default source of
        randomness.
      </td>
    </tr>
    <tr>
      <td>singleton(T o)</td>
      <td>Set&lt;T&gt;</td>
      <td>Returns an immutable set containing only the specified object.</td>
    </tr>
    <tr>
      <td>singletonList(T o)</td>
      <td>List&lt;T&gt;</td>
      <td>Returns an immutable list containing only the specified object.</td>
    </tr>
    <tr>
      <td>singletonMap(K key, V value)</td>
      <td>Map&lt;K, V&gt;</td>
      <td>
        Returns an immutable map containing only the specified key-value pair.
      </td>
    </tr>
    <tr>
      <td>sort(List&lt;T&gt; list)</td>
      <td>void</td>
      <td>
        Sorts the specified list into ascending order, according to the natural
        ordering of its elements.
      </td>
    </tr>
    <tr>
      <td>swap(List&lt;?&gt; list, int i, int j)</td>
      <td>void</td>
      <td>
        Swaps the elements at the specified positions in the specified list.
      </td>
    </tr>
    <tr>
      <td>unmodifiableList(List&lt;? extends T&gt; list)</td>
      <td>List&lt;T&gt;</td>
      <td>Returns an unmodifiable view of the specified list.</td>
    </tr>
    <tr>
      <td>unmodifiableMap(Map&lt;? extends K, ? extends V&gt; map)</td>
      <td>Map&lt;K, V&gt;</td>
      <td>Returns an unmodifiable view of the specified map.</td>
    </tr>
    <tr>
      <td>unmodifiableSet(Set&lt;? extends T&gt; s)</td>
      <td>Set&lt;T&gt;</td>
      <td>Returns an unmodifiable view of the specified set.</td>
    </tr>
    <tr>
      <td>unmodifiableCollection(Collection&lt;? extends T&gt; c)</td>
      <td>Collection&lt;T&gt;</td>
      <td>Returns an unmodifiable view of the specified collection.</td>
    </tr>
    <tr>
      <td>unmodifiableSortedMap(SortedMap&lt;K, ? extends V&gt; m)</td>
      <td>SortedMap&lt;K, V&gt;</td>
      <td>Returns an unmodifiable view of the specified sorted map.</td>
    </tr>
    <tr>
      <td>unmodifiableSortedSet(SortedSet&lt;T&gt; s)</td>
      <td>SortedSet&lt;T&gt;</td>
      <td>Returns an unmodifiable view of the specified sorted set.</td>
    </tr>
    <tr>
      <td>unmodifiableNavigableMap(NavigableMap&lt;K, ? extends V&gt; m)</td>
      <td>NavigableMap&lt;K, V&gt;</td>
      <td>Returns an unmodifiable view of the specified navigable map.</td>
    </tr>
    <tr>
      <td>unmodifiableNavigableSet(NavigableSet&lt;T&gt; s)</td>
      <td>NavigableSet&lt;T&gt;</td>
      <td>Returns an unmodifiable view of the specified navigable set.</td>
    </tr>
    <tr>
      <td>rotate(List&lt;?&gt; list, int distance)</td>
      <td>void</td>
      <td>
        Rotates the elements in the specified list by the specified distance.
      </td>
    </tr>
    <tr>
      <td>synchronizedList(List&lt;T&gt; list)</td>
      <td>List&lt;T&gt;</td>
      <td>
        Returns a synchronized (thread-safe) list backed by the specified list.
      </td>
    </tr>
    <tr>
      <td>synchronizedMap(Map&lt;K,V&gt; m)</td>
      <td>Map&lt;K, V&gt;</td>
      <td>
        Returns a synchronized (thread-safe) map backed by the specified map.
      </td>
    </tr>
    <tr>
      <td>synchronizedSet(Set)</td>
    </tr>
  </tbody>
</table>

### 1. `addAll()` Method

Adds all of the specified elements to the specified collection.

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3));
    System.out.println("Before addAll: " + numbers);

    Collections.addAll(numbers, 4, 5, 6);
    System.out.println("After addAll: " + numbers);
  }
}
```
Output:
```
Before addAll: [1, 2, 3]
After addAll: [1, 2, 3, 4, 5, 6]
```

### 2. `asLifoQueue()` Method

Returns a view of a Deque as a Last-In-First-Out (LIFO) Queue.

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    Deque<String> deque = new ArrayDeque<>();
    deque.add("first");
    deque.add("second");
    deque.add("third");
    System.out.println("Original deque: " + deque);

    Queue<String> lifoQueue = Collections.asLifoQueue(deque);
    System.out.println("LIFO Queue: " + lifoQueue);

    System.out.println("Removing from LIFO Queue: " + lifoQueue.poll());
    System.out.println("Queue after removal: " + lifoQueue);
  }
}
```
Output:
```
Original deque: [first, second, third]
LIFO Queue: [third, second, first]
Removing from LIFO Queue: third
Queue after removal: [second, first]
```

### 3. `binarySearch()` Method

Searches the specified list for the specified object using binary search.

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    List<Integer> numbers = Arrays.asList(1, 3, 5, 7, 9);
    int index = Collections.binarySearch(numbers, 7);
    System.out.println("Index of 7: " + index);
  }
}
```
Output:
```
Index of 7: 3
```

### 4. `copy()`

Copies all of the elements from one list into another.

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    List<String> src = Arrays.asList("apple", "banana", "cherry");
    List<String> dest = new ArrayList<>(Arrays.asList("orange", "grape", "melon"));
    System.out.println("Before copy: " + dest);

    Collections.copy(dest, src);
    System.out.println("After copy: " + dest);
  }
}
```
Output:
```
Before copy: [orange, grape, melon]
After copy: [apple, banana, cherry]
```

### 5. `disjoint()`

Returns true if the two specified collections have no elements in common.

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    List<String> list1 = Arrays.asList("apple", "banana", "cherry");
    List<String> list2 = Arrays.asList("grape", "melon", "orange");
    List<String> list3 = Arrays.asList("apple", "grape");

    boolean isDisjoint1 = Collections.disjoint(list1, list2);
    boolean isDisjoint2 = Collections.disjoint(list1, list3);

    System.out.println("Is list1 disjoint with list2? " + isDisjoint1);
    System.out.println("Is list1 disjoint with list3? " + isDisjoint2);
  }
}
```
Output:
```
Is list1 disjoint with list2? true
Is list1 disjoint with list3? false
```

### 6. `fill()`

Replaces all of the elements of the specified list with the specified element.

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    List<String> words = new ArrayList<>(Arrays.asList("apple", "banana", "cherry"));
    System.out.println("Before fill: " + words);

    Collections.fill(words, "orange");
    System.out.println("After fill: " + words);
  }
}
```
Output:
```
Before fill: [apple, banana, cherry]
After fill: [orange, orange, orange]
```

### 7. `frequency()`

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    List<String> words = Arrays.asList("apple", "banana", "apple", "cherry", "apple");
    int freq = Collections.frequency(words, "apple");
    System.out.println("Frequency of 'apple': " + freq);
  }
}
```
Output:
```
Frequency of 'apple': 3
```

### 8. `indexOfSubList()`

Returns the starting position of the first occurrence of the specified target list within the source list.

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    List<String> list1 = Arrays.asList("apple", "banana", "cherry", "banana", "cherry");
    List<String> list2 = Arrays.asList("banana", "cherry");

    int index = Collections.indexOfSubList(list1, list2);
    System.out.println("Index of sublist: " + index);
  }
}
```
Output:
```
Index of sublist: 1
```

### 9. `lastIndexOfSubList()`

Returns the starting position of the last occurrence of the specified target list within the source list.

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    List<String> list1 = Arrays.asList("apple", "banana", "cherry", "banana", "cherry");
    List<String> list2 = Arrays.asList("banana", "cherry");

    int lastIndex = Collections.lastIndexOfSubList(list1, list2);
    System.out.println("Last index of sublist: " + lastIndex);
  }
}
```
Output:
```
Last index of sublist: 3
```

### 10. `list()`

Returns an ArrayList containing the elements returned by the specified enumeration.

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    Vector<String> vector = new Vector<>(Arrays.asList("apple", "banana", "cherry"));
    Enumeration<String> enumeration = vector.elements();

    List<String> list = Collections.list(enumeration);
    System.out.println("List from enumeration: " + list);
  }
}
```

### 11. `max()`

Returns the maximum element of the given collection, according to the natural ordering of its elements.

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    List<Integer> numbers = Arrays.asList(2, 4, 6, 8, 10);
    int max = Collections.max(numbers);
    System.out.println("Maximum value: " + max);
  }
}
```
Output:
```
Maximum value: 10
```

### 12. `min()`

Returns the minimum element of the given collection, according to the natural ordering of its elements.

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    List<Integer> numbers = Arrays.asList(2, 4, 6, 8, 10);
    int min = Collections.min(numbers);
    System.out.println("Minimum value: " + min);
  }
}
```
Output:
```
Minimum value: 2
```

### 13. `nCopies()`

Returns an immutable list consisting of n copies of the specified object.

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    List<String> list = Collections.nCopies(5, "apple");
    System.out.println("List with n copies: " + list);
  }
}
```
Output:
```
List with n copies: [apple, apple, apple, apple, apple]
```

### 14. `replaceAll()`

Replaces all occurrences of one specified value in the list with another.

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    List<String> words = Arrays.asList("apple", "banana", "apple", "cherry");
    System.out.println("Before replaceAll: " + words);

    Collections.replaceAll(words, "apple", "orange");
    System.out.println("After replaceAll: " + words);
  }
}
```
Output:
```
Before replaceAll: [apple, banana, apple, cherry]
After replaceAll: [orange, banana, orange, cherry]
```

### 15. `reverse()`

Reverses the order of the elements in the specified list.

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    List<String> words = Arrays.asList("apple", "banana", "cherry", "date");
    System.out.println("Before reversing: " + words);

    Collections.reverse(words);
    System.out.println("After reversing: " + words);
  }
}
```
Output:
```
Before reversing: [apple, banana, cherry, date]
After reversing: [date, cherry, banana, apple]
```

### 16. `rotate()`

Rotates the elements in the specified list by the specified distance.

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    List<String> words = Arrays.asList("apple", "banana", "cherry", "date");
    System.out.println("Before rotating: " + words);

    Collections.rotate(words, 2);
    System.out.println("After rotating: " + words);
  }
}
```
Output:
```
Before rotating: [apple, banana, cherry, date] 
After rotating: [cherry, date, apple, banana]
```

### 17. `shuffle()`

Randomly permutes the elements in the specified list.

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    List<String> cards = Arrays.asList("Ace", "King", "Queen", "Jack", "10");
    System.out.println("Before shuffling: " + cards);

    Collections.shuffle(cards);
    System.out.println("After shuffling: " + cards);
  }
}
```
Output:
```
Before shuffling: [Ace, King, Queen, Jack, 10]
After shuffling: [Queen, 10, King, Ace, Jack]
```
(Note: The output will vary each time due to the random shuffling.)


### 18. `singleton()`

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    Set<String> singletonSet = Collections.singleton("apple");
    System.out.println("Singleton set: " + singletonSet);
  }
}
```
Output:
```
Singleton set: [apple]
```

### 18. `sort()`

Sorts the specified list into ascending order, according to the natural ordering of its elements.

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    List<Integer> numbers = Arrays.asList(5, 3, 8, 1, 9);
    System.out.println("Before sorting: " + numbers);

    Collections.sort(numbers);
    System.out.println("After sorting: " + numbers);
  }
}
```
Output:
```
Before sorting: [5, 3, 8, 1, 9]
After sorting: [1, 3, 5, 8, 9]
```

### 19. `swap()`

Swaps the elements at the specified positions in the specified list.

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    List<String> words = Arrays.asList("apple", "banana", "cherry");
    System.out.println("Before swap: " + words);

    Collections.swap(words, 0, 2);
    System.out.println("After swap: " + words);
  }
}
```
Output:
```
Before swap: [apple, banana, cherry]
After swap: [cherry, banana, apple]
```

### 20. `unmodifiableList()`

Returns an unmodifiable view of the specified list.

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    List<String> modifiableList = new ArrayList<>(Arrays.asList("apple", "banana", "cherry"));
    List<String> unmodifiableList = Collections.unmodifiableList(modifiableList);

    System.out.println("Unmodifiable list: " + unmodifiableList);

    try {
      unmodifiableList.add("date");
    } catch (UnsupportedOperationException e) {
      System.out.println("Attempting to modify an unmodifiable list throws an exception.");
    }
  }
}
```
Output:
```
Unmodifiable list: [apple, banana, cherry]
Attempting to modify an unmodifiable list throws an exception.
```

[‚¨ÜÔ∏è Back to Top ‚¨ÜÔ∏è](#index)

## List vs Set

| Feature                     | List                                                                                                                                  | Set                                                                                                                                                         |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Definition**              | An ordered collection that allows duplicate elements.                                                                                 | A collection that does not allow duplicate elements.                                                                                                        |
| **Order**                   | Maintains the order of elements as they are inserted.                                                                                 | Does not guarantee any specific order (e.g., `HashSet`), but `LinkedHashSet` maintains insertion order.                                                     |
| **Duplicates**              | Allows duplicate elements.                                                                                                            | Does not allow duplicate elements.                                                                                                                          |
| **Implementation Classes**  | `ArrayList`, `LinkedList`, `Vector`, `Stack`                                                                                          | `HashSet`, `LinkedHashSet`, `TreeSet`                                                                                                                       |
| **Access by Index**         | Provides access to elements by index (e.g., `list.get(index)`).                                                                       | Does not support access by index.                                                                                                                           |
| **Performance (Insertion)** | Generally, `ArrayList` provides constant time insertion, while `LinkedList` provides constant time insertion at the beginning or end. | Generally, `HashSet` provides constant time insertion, `LinkedHashSet` provides constant time insertion, and `TreeSet` provides logarithmic time insertion. |
| **Performance (Search)**    | `ArrayList` provides linear time search, while `LinkedList` provides linear time search.                                              | `HashSet` provides constant time search, `TreeSet` provides logarithmic time search, and `LinkedHashSet` provides constant time search.                     |
| **Performance (Removal)**   | `ArrayList` provides linear time removal, while `LinkedList` provides constant time removal if the node is known.                     | `HashSet` provides constant time removal, `TreeSet` provides logarithmic time removal, and `LinkedHashSet` provides constant time removal.                  |
| **Use Cases**               | Suitable for scenarios where you need to maintain insertion order or access elements by index.                                        | Suitable for scenarios where uniqueness of elements is important, and ordering is not a concern (or you need a specific ordering).                          |
| **Null Elements**           | Allows null elements.                                                                                                                 | Allows null elements in `HashSet` and `LinkedHashSet`, but not in `TreeSet`.                                                                                |
| **Thread-Safety**           | `ArrayList` and `LinkedList` are not thread-safe. `Vector` is synchronized and thread-safe.                                           | `HashSet`, `LinkedHashSet`, and `TreeSet` are not thread-safe.                                                                                              |
| **Examples**                | `List<String> list = new ArrayList<>();`                                                                                              | `Set<String> set = new HashSet<>();`                                                                                                                        |


[‚¨ÜÔ∏è Back to Top ‚¨ÜÔ∏è](#index)
## List vs Map

| Feature                     | List                                                                                                                                  | Map                                                                                                                                                                                                     |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Definition**              | An ordered collection that allows duplicate elements.                                                                                 | An object that maps keys to values, with no duplicate keys allowed.                                                                                                                                     |
| **Order**                   | Maintains the order of elements as they are inserted.                                                                                 | Order of elements depends on the implementation (e.g., `HashMap` does not guarantee order, while `LinkedHashMap` maintains insertion order and `TreeMap` maintains natural or specified order of keys). |
| **Duplicates**              | Allows duplicate elements.                                                                                                            | Does not allow duplicate keys. Values can be duplicated.                                                                                                                                                |
| **Implementation Classes**  | `ArrayList`, `LinkedList`, `Vector`, `Stack`                                                                                          | `HashMap`, `LinkedHashMap`, `TreeMap`, `Hashtable`                                                                                                                                                      |
| **Access**                  | Provides access to elements by index (e.g., `list.get(index)`).                                                                       | Provides access to values by key (e.g., `map.get(key)`).                                                                                                                                                |
| **Performance (Insertion)** | Generally, `ArrayList` provides constant time insertion, while `LinkedList` provides constant time insertion at the beginning or end. | `HashMap` provides constant time insertion, `LinkedHashMap` provides constant time insertion, and `TreeMap` provides logarithmic time insertion.                                                        |
| **Performance (Search)**    | `ArrayList` provides linear time search, while `LinkedList` provides linear time search.                                              | Search time is constant for `HashMap`, logarithmic for `TreeMap`, and constant for `LinkedHashMap`.                                                                                                     |
| **Performance (Removal)**   | `ArrayList` provides linear time removal, while `LinkedList` provides constant time removal if the node is known.                     | Removal time is constant for `HashMap`, logarithmic for `TreeMap`, and constant for `LinkedHashMap`.                                                                                                    |
| **Use Cases**               | Suitable for scenarios where you need to maintain insertion order or access elements by index.                                        | Suitable for scenarios where you need to associate keys with values and retrieve values based on keys.                                                                                                  |
| **Null Elements**           | Allows null elements.                                                                                                                 | Allows null keys and values in `HashMap` and `LinkedHashMap`, but not in `TreeMap` (null keys are not allowed in `TreeMap`).                                                                            |
| **Thread-Safety**           | `ArrayList` and `LinkedList` are not thread-safe. `Vector` is synchronized and thread-safe.                                           | `HashMap`, `LinkedHashMap`, and `TreeMap` are not thread-safe. `Hashtable` is synchronized and thread-safe.                                                                                             |
| **Examples**                | `List<String> list = new ArrayList<>();`                                                                                              | `Map<String, Integer> map = new HashMap<>();`                                                                                                                                                           |


[‚¨ÜÔ∏è Back to Top ‚¨ÜÔ∏è](#index)
## Map vs Set

| Feature                     | Map                                                                                                                                                                                                     | Set                                                                                                                                                         |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Definition**              | An object that maps keys to values, with no duplicate keys allowed.                                                                                                                                     | A collection that does not allow duplicate elements.                                                                                                        |
| **Order**                   | Order of elements depends on the implementation (e.g., `HashMap` does not guarantee order, while `LinkedHashMap` maintains insertion order and `TreeMap` maintains natural or specified order of keys). | Does not guarantee any specific order (e.g., `HashSet`), but `LinkedHashSet` maintains insertion order.                                                     |
| **Duplicates**              | Does not allow duplicate keys. Values can be duplicated.                                                                                                                                                | Does not allow duplicate elements.                                                                                                                          |
| **Implementation Classes**  | `HashMap`, `LinkedHashMap`, `TreeMap`, `Hashtable`                                                                                                                                                      | `HashSet`, `LinkedHashSet`, `TreeSet`                                                                                                                       |
| **Access**                  | Provides access to values by key (e.g., `map.get(key)`).                                                                                                                                                | Does not support access by index or key.                                                                                                                    |
| **Performance (Insertion)** | `HashMap` provides constant time insertion, `LinkedHashMap` provides constant time insertion, and `TreeMap` provides logarithmic time insertion.                                                        | Generally, `HashSet` provides constant time insertion, `LinkedHashSet` provides constant time insertion, and `TreeSet` provides logarithmic time insertion. |
| **Performance (Search)**    | Search time is constant for `HashMap`, logarithmic for `TreeMap`, and constant for `LinkedHashMap`.                                                                                                     | `HashSet` provides constant time search, `TreeSet` provides logarithmic time search, and `LinkedHashSet` provides constant time search.                     |
| **Performance (Removal)**   | Removal time is constant for `HashMap`, logarithmic for `TreeMap`, and constant for `LinkedHashMap`.                                                                                                    | `HashSet` provides constant time removal, `TreeSet` provides logarithmic time removal, and `LinkedHashSet` provides constant time removal.                  |
| **Use Cases**               | Suitable for scenarios where you need to associate keys with values and retrieve values based on keys.                                                                                                  | Suitable for scenarios where uniqueness of elements is important, and ordering is not a concern (or you need a specific ordering).                          |
| **Null Elements**           | Allows null keys and values in `HashMap` and `LinkedHashMap`, but not in `TreeMap` (null keys are not allowed in `TreeMap`).                                                                            | Allows null elements in `HashSet` and `LinkedHashSet`, but not in `TreeSet`.                                                                                |
| **Thread-Safety**           | `HashMap`, `LinkedHashMap`, and `TreeMap` are not thread-safe. `Hashtable` is synchronized and thread-safe.                                                                                             | `HashSet`, `LinkedHashSet`, and `TreeSet` are not thread-safe.                                                                                              |
| **Examples**                | `Map<String, Integer> map = new HashMap<>();`                                                                                                                                                           | `Set<String> set = new HashSet<>();`                                                                                                                        |


[‚¨ÜÔ∏è Back to Top ‚¨ÜÔ∏è](#index)
## ArrayList vs Vector

| Feature             | ArrayList                                                                                       | Vector                                                                              |
| ------------------- | ----------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| **Definition**      | A resizable array implementation of the `List` interface.                                       | A resizable array implementation of the `List` interface with synchronized methods. |
| **Synchronization** | Not synchronized. It is not thread-safe.                                                        | Synchronized. It is thread-safe.                                                    |
| **Performance**     | Generally faster than `Vector` because it is not synchronized.                                  | Generally slower than `ArrayList` due to synchronization overhead.                  |
| **Growth Policy**   | Increases size by 50% when the array is full.                                                   | Increases size by doubling when the array is full.                                  |
| **Legacy**          | Introduced in JDK 1.2 as part of the `Collections Framework`.                                   | Introduced in JDK 1.0 and part of the original Java version.                        |
| **Methods**         | Does not include methods that are specific to legacy classes.                                   | Includes legacy methods such as `elements()` that are not present in `ArrayList`.   |
| **Use Case**        | Preferred for most applications due to better performance and lack of synchronization overhead. | Used when thread safety is required and no external synchronization is desired.     |
| **Examples**        | `ArrayList<String> list = new ArrayList<>();`                                                   | `Vector<String> vector = new Vector<>();`                                           |


[‚¨ÜÔ∏è Back to Top ‚¨ÜÔ∏è](#index)
## ArrayList vs LinkedList

| Feature                             | ArrayList                                                                                                       | LinkedList                                                                                                                          |
| ----------------------------------- | --------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| **Definition**                      | A resizable array implementation of the `List` interface.                                                       | A doubly linked list implementation of the `List` interface.                                                                        |
| **Underlying Data Structure**       | Uses a dynamic array to store elements.                                                                         | Uses a doubly linked list to store elements.                                                                                        |
| **Performance (Access)**            | Provides fast random access to elements (constant time `get(index)`).                                           | Provides slower random access (linear time `get(index)`), but fast access to neighboring elements.                                  |
| **Performance (Insertion/Removal)** | Fast at the end of the list (constant time), but slow for insertions/removals in the middle (linear time).      | Fast insertions and removals at the beginning or end (constant time), but slow for insertions/removals in the middle (linear time). |
| **Memory Usage**                    | Uses less memory per element (just the array overhead).                                                         | Uses more memory per element (additional storage for node references).                                                              |
| **Resize Operation**                | Automatically resizes the array when needed (requires array copying).                                           | Does not require resizing as it grows dynamically (no array copying).                                                               |
| **Thread-Safety**                   | Not synchronized. It is not thread-safe.                                                                        | Not synchronized. It is not thread-safe.                                                                                            |
| **Use Case**                        | Preferred when frequent access to elements by index is required and when memory overhead needs to be minimized. | Preferred when frequent insertions and deletions are required, especially at the beginning or end of the list.                      |
| **Examples**                        | `ArrayList<String> arrayList = new ArrayList<>();`                                                              | `LinkedList<String> linkedList = new LinkedList<>();`                                                                               |


[‚¨ÜÔ∏è Back to Top ‚¨ÜÔ∏è](#index)
## LinkedList vs Vector

| Feature                             | LinkedList                                                                                                     | Vector                                                                                                                   |
| ----------------------------------- | -------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| **Definition**                      | A doubly linked list implementation of the `List` interface.                                                   | A resizable array implementation of the `List` interface with synchronized methods.                                      |
| **Underlying Data Structure**       | Uses a doubly linked list to store elements.                                                                   | Uses a dynamic array to store elements.                                                                                  |
| **Performance (Access)**            | Provides slower random access (linear time `get(index)`), but fast access to neighboring elements.             | Provides fast random access (constant time `get(index)`).                                                                |
| **Performance (Insertion/Removal)** | Fast insertions and removals at the beginning or end (constant time), but slower in the middle (linear time).  | Fast at the end of the list (constant time), but slow for insertions/removals in the middle (linear time).               |
| **Memory Usage**                    | Uses more memory per element (additional storage for node references).                                         | Uses less memory per element (just the array overhead).                                                                  |
| **Synchronization**                 | Not synchronized. It is not thread-safe.                                                                       | Synchronized. It is thread-safe.                                                                                         |
| **Resize Operation**                | Does not require resizing as it grows dynamically (no array copying).                                          | Automatically resizes the array when needed (requires array copying).                                                    |
| **Use Case**                        | Preferred when frequent insertions and deletions are required, especially at the beginning or end of the list. | Preferred when you need a thread-safe implementation and when the performance overhead of synchronization is acceptable. |
| **Examples**                        | `LinkedList<String> linkedList = new LinkedList<>();`                                                          | `Vector<String> vector = new Vector<>();`                                                                                |


[‚¨ÜÔ∏è Back to Top ‚¨ÜÔ∏è](#index)
## HashSet vs TreeSet

| Feature                              | HashSet                                                                                                              | TreeSet                                                                                                                                                                           |
| ------------------------------------ | -------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Definition**                       | A set implementation that uses a hash table for storage.                                                             | A set implementation that uses a Red-Black tree for storage.                                                                                                                      |
| **Ordering**                         | Does not guarantee any specific order of elements. The order is based on the hash codes of the elements.             | Maintains elements in a sorted order according to their natural ordering or a specified comparator.                                                                               |
| **Performance (Insertion/Deletion)** | Provides constant time complexity (O(1)) for basic operations (add, remove, contains) assuming a good hash function. | Provides logarithmic time complexity (O(log n)) for basic operations (add, remove, contains) due to the underlying Red-Black tree.                                                |
| **Null Elements**                    | Allows a single null element.                                                                                        | Allows a single null element if the natural ordering or comparator allows it (but the comparator must handle null values). Generally, it is better to avoid nulls in a `TreeSet`. |
| **Memory Usage**                     | Generally uses less memory compared to `TreeSet` due to the hash table overhead.                                     | Generally uses more memory due to the Red-Black tree structure and associated node references.                                                                                    |
| **Thread-Safety**                    | Not synchronized. It is not thread-safe.                                                                             | Not synchronized. It is not thread-safe.                                                                                                                                          |
| **Use Case**                         | Preferred when you need a set with fast operations and don't need sorted order.                                      | Preferred when you need a set that maintains elements in a sorted order.                                                                                                          |
| **Examples**                         | `HashSet<String> hashSet = new HashSet<>();`                                                                         | `TreeSet<String> treeSet = new TreeSet<>();`                                                                                                                                      |

[‚¨ÜÔ∏è Back to Top ‚¨ÜÔ∏è](#index)
## HashSet vs LinkedHashSet

| Feature                              | HashSet                                                                                                              | LinkedHashSet                                                                                                                                                  |
| ------------------------------------ | -------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Definition**                       | A set implementation that uses a hash table for storage.                                                             | A set implementation that uses a hash table and a linked list for storage, preserving insertion order.                                                         |
| **Ordering**                         | Does not guarantee any specific order of elements. The order is based on the hash codes of the elements.             | Maintains elements in the order they were inserted, due to the linked list component.                                                                          |
| **Performance (Insertion/Deletion)** | Provides constant time complexity (O(1)) for basic operations (add, remove, contains) assuming a good hash function. | Provides slightly slower constant time complexity (O(1)) for basic operations compared to `HashSet` due to additional overhead of maintaining the linked list. |
| **Memory Usage**                     | Generally uses less memory compared to `LinkedHashSet` because it only uses a hash table.                            | Uses more memory due to the additional overhead of the linked list used to maintain insertion order.                                                           |
| **Null Elements**                    | Allows a single null element.                                                                                        | Allows a single null element.                                                                                                                                  |
| **Thread-Safety**                    | Not synchronized. It is not thread-safe.                                                                             | Not synchronized. It is not thread-safe.                                                                                                                       |
| **Use Case**                         | Preferred when you need a set with fast operations and do not require element ordering.                              | Preferred when you need a set that maintains the order of elements as they were inserted, with slightly higher memory overhead.                                |
| **Examples**                         | `HashSet<String> hashSet = new HashSet<>();`                                                                         | `LinkedHashSet<String> linkedHashSet = new LinkedHashSet<>();`                                                                                                 |


[‚¨ÜÔ∏è Back to Top ‚¨ÜÔ∏è](#index)
## LinkedHashSet vs TreeSet

| Feature                              | LinkedHashSet                                                                                                                        | TreeSet                                                                                                                           |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------- |
| **Definition**                       | A set implementation that uses a hash table and a linked list for storage, preserving insertion order.                               | A set implementation that uses a Red-Black tree for storage, maintaining a sorted order.                                          |
| **Ordering**                         | Maintains elements in the order they were inserted, due to the linked list component.                                                | Maintains elements in a sorted order according to their natural ordering or a specified comparator.                               |
| **Performance (Insertion/Deletion)** | Provides slightly slower constant time complexity (O(1)) for basic operations compared to `HashSet` due to the linked list overhead. | Provides logarithmic time complexity (O(log n)) for basic operations (add, remove, contains) due to the Red-Black tree structure. |
| **Memory Usage**                     | Uses more memory than `HashSet` due to the additional overhead of the linked list used to maintain insertion order.                  | Uses more memory than `LinkedHashSet` due to the Red-Black tree structure and additional node references.                         |
| **Null Elements**                    | Allows a single null element.                                                                                                        | Does not allow null elements, as the tree requires natural ordering or a comparator that cannot handle null.                      |
| **Thread-Safety**                    | Not synchronized. It is not thread-safe.                                                                                             | Not synchronized. It is not thread-safe.                                                                                          |
| **Use Case**                         | Preferred when you need a set that maintains the insertion order of elements with minimal performance overhead.                      | Preferred when you need a set that maintains a sorted order of elements, and the order is important.                              |
| **Examples**                         | `LinkedHashSet<String> linkedHashSet = new LinkedHashSet<>();`                                                                       | `TreeSet<String> treeSet = new TreeSet<>();`                                                                                      |


[‚¨ÜÔ∏è Back to Top ‚¨ÜÔ∏è](#index)
## HashTable vs HashMap

| Feature              | Hashtable                                                                                                     | HashMap                                                                                                                      |
| -------------------- | ------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| **Definition**       | A legacy class that implements a synchronized hash table for key-value pairs.                                 | A modern class that implements an unsynchronized hash table for key-value pairs.                                             |
| **Synchronization**  | Synchronized. It is thread-safe, meaning multiple threads can access it concurrently without corrupting data. | Not synchronized. It is not thread-safe and requires external synchronization for use in concurrent contexts.                |
| **Null Keys/Values** | Does not allow null keys or null values.                                                                      | Allows one null key and multiple null values.                                                                                |
| **Performance**      | Generally slower due to synchronization overhead.                                                             | Generally faster due to lack of synchronization overhead.                                                                    |
| **Legacy Status**    | Introduced in JDK 1.0. Considered a legacy class.                                                             | Introduced in JDK 1.2 as part of the Collections Framework. Not a legacy class.                                              |
| **Thread-Safety**    | Built-in thread safety due to synchronized methods.                                                           | Not thread-safe. Use `Collections.synchronizedMap` or `ConcurrentHashMap` for thread-safe operations.                        |
| **Iterator**         | The iterator is not fail-fast.                                                                                | The iterator is fail-fast, meaning it will throw a `ConcurrentModificationException` if the map is modified while iterating. |
| **Use Case**         | Suitable for legacy code that requires a thread-safe implementation of a hash table.                          | Preferred for most modern applications due to better performance and support for null values.                                |
| **Examples**         | `Hashtable<String, Integer> hashtable = new Hashtable<>();`                                                   | `HashMap<String, Integer> hashMap = new HashMap<>();`                                                                        |


[‚¨ÜÔ∏è Back to Top ‚¨ÜÔ∏è](#index)
## HashTable vs LinkedHashMap

| Feature              | Hashtable                                                                                                     | LinkedHashMap                                                                                                                                         |
| -------------------- | ------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Definition**       | A legacy class that implements a synchronized hash table for key-value pairs.                                 | A hash table and linked list implementation of the `Map` interface that maintains insertion order.                                                    |
| **Synchronization**  | Synchronized. It is thread-safe, meaning multiple threads can access it concurrently without corrupting data. | Not synchronized. It is not thread-safe and requires external synchronization for use in concurrent contexts.                                         |
| **Null Keys/Values** | Does not allow null keys or null values.                                                                      | Allows one null key and multiple null values.                                                                                                         |
| **Ordering**         | Does not guarantee any specific order of elements. The order is based on the hash codes of the elements.      | Maintains elements in the order they were inserted, due to the linked list component.                                                                 |
| **Performance**      | Generally slower due to synchronization overhead.                                                             | Provides slightly slower performance than `HashMap` due to additional overhead of maintaining the linked list, but generally faster than `Hashtable`. |
| **Legacy Status**    | Introduced in JDK 1.0. Considered a legacy class.                                                             | Introduced in JDK 1.2 as part of the Collections Framework. Not a legacy class.                                                                       |
| **Thread-Safety**    | Built-in thread safety due to synchronized methods.                                                           | Not thread-safe. Use `Collections.synchronizedMap` for thread-safe operations.                                                                        |
| **Iterator**         | The iterator is not fail-fast.                                                                                | The iterator is fail-fast, meaning it will throw a `ConcurrentModificationException` if the map is modified while iterating.                          |
| **Use Case**         | Suitable for legacy code that requires a thread-safe implementation of a hash table.                          | Preferred when you need a map that maintains insertion order with better performance than `Hashtable`.                                                |
| **Examples**         | `Hashtable<String, Integer> hashtable = new Hashtable<>();`                                                   | `LinkedHashMap<String, Integer> linkedHashMap = new LinkedHashMap<>();`                                                                               |


[‚¨ÜÔ∏è Back to Top ‚¨ÜÔ∏è](#index)
## HashMap vs LinkedHashMap

| Feature                              | HashMap                                                                                                                      | LinkedHashMap                                                                                                                                                  |
| ------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Definition**                       | A hash table-based implementation of the `Map` interface.                                                                    | A hash table and linked list implementation of the `Map` interface that maintains insertion order.                                                             |
| **Ordering**                         | Does not guarantee any specific order of elements. The order is based on the hash codes of the elements.                     | Maintains elements in the order they were inserted, due to the linked list component.                                                                          |
| **Performance (Insertion/Deletion)** | Provides constant time complexity (O(1)) for basic operations (add, remove, contains) assuming a good hash function.         | Provides slightly slower constant time complexity (O(1)) for basic operations compared to `HashMap` due to additional overhead of maintaining the linked list. |
| **Memory Usage**                     | Generally uses less memory compared to `LinkedHashMap` because it only uses a hash table.                                    | Uses more memory due to the additional overhead of the linked list used to maintain insertion order.                                                           |
| **Null Keys/Values**                 | Allows one null key and multiple null values.                                                                                | Allows one null key and multiple null values.                                                                                                                  |
| **Thread-Safety**                    | Not synchronized. It is not thread-safe and requires external synchronization for use in concurrent contexts.                | Not synchronized. It is not thread-safe and requires external synchronization for use in concurrent contexts.                                                  |
| **Iterator**                         | The iterator is fail-fast, meaning it will throw a `ConcurrentModificationException` if the map is modified while iterating. | The iterator is fail-fast, meaning it will throw a `ConcurrentModificationException` if the map is modified while iterating.                                   |
| **Use Case**                         | Preferred when you do not need to maintain the order of elements and want a map with better performance.                     | Preferred when you need a map that maintains the order of elements as they were inserted, with slightly higher memory overhead.                                |
| **Examples**                         | `HashMap<String, Integer> hashMap = new HashMap<>();`                                                                        | `LinkedHashMap<String, Integer> linkedHashMap = new LinkedHashMap<>();`                                                                                        |




<hr/>

[üè† Home](../../../README.md) <br/>
[üçµ Java Home](../Java.md)